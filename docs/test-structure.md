# Test Plan

`mutagen`'s logic is tested using unit tests and integration tests. The integration tests need a

## Unit tests of mutators

The behavior of all mutators is tested using traditional unit tests in the corresponding modules. The mutators are run with run-time configurations constructed by the test itself.

## Tests of `#[mutate]`

The behavior of the `#[mutate]` attribute for single transformers is tested along the unit tests in each mutator.

### Test Isolation

Instead of having a program-wide unique id per mutation, each function can have their own local mutation ids by writing adding `conf(local)` to the arguments of `#[mutate]`. This ensures that each test is independent from others. Moreover, only one transformer is enabled in each test. This is done by adding `only(...)` to the mutagen arguments.

### Exhaustive Testing

Each test sets the global `mutation_id` for the single test run and runs test code. This enables exhaustive testing of all mutations within a single run of the test suite and without dependency on external environment variables.

### Implementation Details

The code generated by `#[mutate]` references the mutators by absolute path import. (i.e. `::mutagen::..`). It is necessary to add mutagen as a dev-dependency of itself. This ensures that the path `::mutagen::...` is valid during tests.

The setting of the `mutation_id` during test is possible via special functions that mutate the global run-time configuration and are only available when enabling the feature `self_test` of `mutagen`. The feature `self_test` is not supposed to be used by users of `mutagen`.

The feature `self_test` is necessary and the `#[cfg(feature="self_test")]` cannot be replaced by `#[cfg(test)]`, since the version of mutagen that is included as a dev-dependency id not compiled in `test` mode.

The current approach *works*, but quite hacky. If you come up with a nicer solution that implements the points mentioned in exhaustive testing and test isolation above, a PR is welcome.

## Example

Typically, a complete test setup looks like this
```rust
// only enable mutator `xyz`
#[mutate(conf(local), only(xzy))]
pub fn x() {
    // function to mutate
}

#[test]
pub fn x_inactive() {
    test_with_mutation_id(0, || {
        // test and assert on `x()` where no mutations have been performed
    })
}
#[test]
pub fn x_active() {
    test_with_mutation_id(1, || {
        // test and assert that the correct mutation has been performed in `x()`
    })
}

// more tests with other mutation ids, if more than one mutation has been performed
```
